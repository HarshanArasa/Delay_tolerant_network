<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vehicular DTN Simulation</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        body {
            background: linear-gradient(135deg, #1a2a6c, #b21f1f, #fdbb2d);
            color: white;
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: rgba(0, 0, 0, 0.7);
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            overflow: hidden;
        }

        header {
            background: rgba(0, 0, 0, 0.8);
            padding: 25px;
            text-align: center;
            border-bottom: 2px solid #3498db;
        }

        h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            color: #3498db;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }

        .subtitle {
            font-size: 1.2em;
            opacity: 0.9;
            max-width: 800px;
            margin: 0 auto;
            line-height: 1.6;
        }

        .simulation-area {
            padding: 25px;
            display: grid;
            grid-template-columns: 1fr 300px;
            gap: 25px;
        }

        @media (max-width: 768px) {
            .simulation-area {
                grid-template-columns: 1fr;
            }
        }

        .visualization {
            position: relative;
            background: #0c2461;
            border-radius: 10px;
            overflow: hidden;
            border: 3px solid #1e3799;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        }

        #simulationCanvas {
            display: block;
            background: #0c2461;
        }

        .controls {
            display: flex;
            gap: 15px;
            padding: 20px;
            background: rgba(0, 0, 0, 0.5);
            border-bottom: 1px solid #3498db;
        }

        button {
            padding: 12px 20px;
            border: none;
            border-radius: 8px;
            background: linear-gradient(135deg, #3498db, #2980b9);
            color: white;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            flex: 1;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.4);
        }

        button:disabled {
            background: #7f8c8d;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        #addMessageBtn {
            background: linear-gradient(135deg, #27ae60, #229954);
        }

        #resetBtn {
            background: linear-gradient(135deg, #e74c3c, #c0392b);
        }

        .speed-control {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 0 20px;
            background: rgba(0, 0, 0, 0.5);
            color: white;
        }

        #speedSlider {
            flex: 1;
        }

        .info-panel {
            background: rgba(0, 0, 0, 0.7);
            border-radius: 10px;
            padding: 20px;
            border: 2px solid #3498db;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        }

        .panel-title {
            font-size: 1.5em;
            margin-bottom: 15px;
            color: #3498db;
            text-align: center;
            border-bottom: 1px solid #3498db;
            padding-bottom: 10px;
        }

        .stats {
            display: grid;
            grid-template-columns: 1fr;
            gap: 15px;
            margin-bottom: 25px;
        }

        .stat-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px;
            background: rgba(52, 152, 219, 0.2);
            border-radius: 8px;
            border-left: 4px solid #3498db;
        }

        .stat-label {
            font-weight: bold;
        }

        .stat-value {
            font-weight: bold;
            color: #2ecc71;
        }

        .legend {
            margin-top: 20px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 12px;
            padding: 8px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 6px;
        }

        .car-sample {
            width: 20px;
            height: 10px;
            border-radius: 3px;
        }

        .car-normal {
            background: #3498db;
        }

        .car-message {
            background: #e74c3c;
        }

        .connection-sample {
            width: 30px;
            height: 3px;
            background: #2ecc71;
        }

        .message-log {
            margin-top: 25px;
            max-height: 300px;
            overflow-y: auto;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 8px;
            padding: 15px;
        }

        .log-title {
            font-size: 1.2em;
            margin-bottom: 10px;
            color: #3498db;
            text-align: center;
        }

        .event-log {
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
        }

        .event-log div {
            padding: 8px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            animation: fadeIn 0.5s ease;
        }

        .event-log div:last-child {
            border-bottom: none;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-5px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .dtn-explanation {
            margin-top: 25px;
            padding: 15px;
            background: rgba(52, 152, 219, 0.2);
            border-radius: 8px;
            border-left: 4px solid #3498db;
            font-size: 0.95em;
            line-height: 1.5;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Vehicular Delay Tolerant Network (DTN) Simulation</h1>
            <p class="subtitle">
                This simulation demonstrates how vehicles can communicate in disconnected environments 
                using store-carry-forward messaging. When vehicles come within range, they exchange messages, 
                creating an ad-hoc network without requiring continuous connectivity.
            </p>
        </header>

        <div class="controls">
            <button id="startBtn">Start Simulation</button>
            <button id="pauseBtn" disabled>Pause</button>
            <button id="resetBtn">Reset</button>
            <button id="addMessageBtn">Add Message</button>
        </div>

        <div class="speed-control">
            <label for="speedSlider">Simulation Speed:</label>
            <input type="range" id="speedSlider" min="1" max="10" value="5">
        </div>

        <div class="simulation-area">
            <div class="visualization">
                <canvas id="simulationCanvas" width="800" height="500"></canvas>
            </div>

            <div class="info-panel">
                <div class="panel-title">Simulation Statistics</div>
                
                <div class="stats">
                    <div class="stat-item">
                        <span class="stat-label">Active Vehicles:</span>
                        <span id="nodeCount" class="stat-value">6</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">Total Messages:</span>
                        <span id="totalMessages" class="stat-value">0</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">Delivered Messages:</span>
                        <span id="deliveredMessages" class="stat-value">0</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">Delivery Rate:</span>
                        <span id="deliveryRate" class="stat-value">0%</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">Average Hops:</span>
                        <span id="avgHops" class="stat-value">0</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">Average Delay:</span>
                        <span id="avgDelay" class="stat-value">0s</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">Active Connections:</span>
                        <span id="activeConnections" class="stat-value">0</span>
                    </div>
                </div>

                <div class="legend">
                    <div class="panel-title">Legend</div>
                    <div class="legend-item">
                        <div class="car-sample car-normal"></div>
                        <span>Vehicle (No Messages)</span>
                    </div>
                    <div class="legend-item">
                        <div class="car-sample car-message"></div>
                        <span>Vehicle (Carrying Messages)</span>
                    </div>
                    <div class="legend-item">
                        <div class="connection-sample"></div>
                        <span>Message Exchange</span>
                    </div>
                </div>

                <div class="dtn-explanation">
                    <p><strong>How DTN Works:</strong></p>
                    <p>Vehicles store messages when no other nodes are in range. When vehicles come within communication range (shown with connecting lines), they exchange all stored messages. This store-carry-forward approach enables communication in disconnected environments.</p>
                </div>
            </div>
        </div>

        <div class="message-log">
            <div class="log-title">Message Events</div>
            <div id="eventLog" class="event-log"></div>
        </div>
    </div>

    <script>
        class VehicularDTNSimulation {
            constructor() {
                this.canvas = document.getElementById('simulationCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.nodes = [];
                this.messages = [];
                this.connections = [];
                this.isRunning = false;
                this.animationId = null;
                this.lastTimestamp = 0;
                this.simulationTime = 0;
                
                // Statistics
                this.stats = {
                    totalMessages: 0,
                    deliveredMessages: 0,
                    totalHops: 0,
                    totalDelay: 0,
                    activeConnections: 0
                };

                this.init();
            }

            init() {
                this.createNodes(6);
                this.setupEventListeners();
                this.updateStats();
                this.draw();
            }

            createNodes(count) {
                this.nodes = [];
                const roadSegments = this.generateRoadSegments();
                
                for (let i = 0; i < count; i++) {
                    const segment = roadSegments[i % roadSegments.length];
                    const isHorizontal = segment.direction === 'horizontal';
                    
                    this.nodes.push({
                        id: i,
                        x: isHorizontal ? segment.startX : segment.x,
                        y: isHorizontal ? segment.y : segment.startY,
                        vx: isHorizontal ? (Math.random() * 2 + 1) * (Math.random() > 0.5 ? 1 : -1) : 0,
                        vy: isHorizontal ? 0 : (Math.random() * 2 + 1) * (Math.random() > 0.5 ? 1 : -1),
                        width: 30,
                        height: 15,
                        color: '#3498db',
                        messages: [],
                        hasMessages: false,
                        roadSegment: segment,
                        direction: segment.direction
                    });
                }
            }

            generateRoadSegments() {
                const segments = [];
                // Horizontal roads
                segments.push({startX: 0, y: 100, endX: this.canvas.width, direction: 'horizontal'});
                segments.push({startX: 0, y: 250, endX: this.canvas.width, direction: 'horizontal'});
                segments.push({startX: 0, y: 400, endX: this.canvas.width, direction: 'horizontal'});
                
                // Vertical roads
                segments.push({x: 200, startY: 0, endY: this.canvas.height, direction: 'vertical'});
                segments.push({x: 500, startY: 0, endY: this.canvas.height, direction: 'vertical'});
                
                return segments;
            }

            setupEventListeners() {
                document.getElementById('startBtn').addEventListener('click', () => this.start());
                document.getElementById('pauseBtn').addEventListener('click', () => this.pause());
                document.getElementById('resetBtn').addEventListener('click', () => this.reset());
                document.getElementById('addMessageBtn').addEventListener('click', () => this.addRandomMessage());
                document.getElementById('speedSlider').addEventListener('input', (e) => this.updateSpeed(e.target.value));
            }

            start() {
                if (!this.isRunning) {
                    this.isRunning = true;
                    document.getElementById('startBtn').disabled = true;
                    document.getElementById('pauseBtn').disabled = false;
                    this.lastTimestamp = performance.now();
                    this.animate();
                }
            }

            pause() {
                this.isRunning = false;
                document.getElementById('startBtn').disabled = false;
                document.getElementById('pauseBtn').disabled = true;
                if (this.animationId) {
                    cancelAnimationFrame(this.animationId);
                }
            }

            reset() {
                this.pause();
                this.messages = [];
                this.connections = [];
                this.simulationTime = 0;
                this.stats = {
                    totalMessages: 0,
                    deliveredMessages: 0,
                    totalHops: 0,
                    totalDelay: 0,
                    activeConnections: 0
                };
                this.createNodes(6);
                this.clearEventLog();
                this.updateStats();
                this.draw();
            }

            updateSpeed(value) {
                // Speed is handled in the animation loop
            }

            addRandomMessage() {
                if (this.nodes.length < 2) return;

                const source = Math.floor(Math.random() * this.nodes.length);
                let target = Math.floor(Math.random() * this.nodes.length);
                while (target === source) {
                    target = Math.floor(Math.random() * this.nodes.length);
                }

                const message = {
                    id: this.stats.totalMessages,
                    source: source,
                    target: target,
                    createdAt: this.simulationTime,
                    delivered: false,
                    deliveryTime: null,
                    hopCount: 0,
                    path: [source]
                };

                this.messages.push(message);
                this.nodes[source].messages.push(message);
                this.nodes[source].hasMessages = true;
                this.nodes[source].color = '#e74c3c';

                this.stats.totalMessages++;
                this.logEvent(`Message ${message.id} created: Vehicle ${source} → Vehicle ${target}`);
                this.updateStats();
            }

            animate(currentTime = 0) {
                if (!this.isRunning) return;

                const deltaTime = currentTime - this.lastTimestamp;
                const speed = document.getElementById('speedSlider').value;
                
                if (deltaTime > 1000 / (10 + speed * 5)) {
                    this.update();
                    this.simulationTime += 0.1;
                    this.lastTimestamp = currentTime;
                }

                this.draw();
                this.animationId = requestAnimationFrame((time) => this.animate(time));
            }

            update() {
                // Update vehicle positions
                this.nodes.forEach(node => {
                    const segment = node.roadSegment;
                    
                    if (node.direction === 'horizontal') {
                        node.x += node.vx;
                        
                        // Reverse direction at road ends
                        if (node.x < segment.startX || node.x > segment.endX) {
                            node.vx *= -1;
                            // Ensure vehicle stays on road
                            node.x = Math.max(segment.startX, Math.min(segment.endX, node.x));
                        }
                    } else {
                        node.y += node.vy;
                        
                        // Reverse direction at road ends
                        if (node.y < segment.startY || node.y > segment.endY) {
                            node.vy *= -1;
                            // Ensure vehicle stays on road
                            node.y = Math.max(segment.startY, Math.min(segment.endY, node.y));
                        }
                    }
                });

                // Check for connections and exchange messages
                this.connections = [];
                for (let i = 0; i < this.nodes.length; i++) {
                    for (let j = i + 1; j < this.nodes.length; j++) {
                        const nodeA = this.nodes[i];
                        const nodeB = this.nodes[j];
                        const distance = Math.sqrt(
                            Math.pow(nodeA.x - nodeB.x, 2) + Math.pow(nodeA.y - nodeB.y, 2)
                        );

                        if (distance < 100) { // Communication range
                            this.connections.push({ nodeA, nodeB });
                            this.exchangeMessages(nodeA, nodeB);
                        }
                    }
                }

                this.stats.activeConnections = this.connections.length;
                this.updateStats();
            }

            exchangeMessages(nodeA, nodeB) {
                let exchanged = false;

                // NodeA to NodeB
                const messagesFromA = [...nodeA.messages];
                messagesFromA.forEach(message => {
                    if (!nodeB.messages.some(m => m.id === message.id)) {
                        const messageCopy = {...message};
                        messageCopy.hopCount++;
                        messageCopy.path.push(nodeB.id);
                        nodeB.messages.push(messageCopy);
                        nodeB.hasMessages = true;
                        nodeB.color = '#e74c3c';
                        exchanged = true;
                        
                        // Check if message reached its target
                        if (message.target === nodeB.id && !message.delivered) {
                            message.delivered = true;
                            message.deliveryTime = this.simulationTime;
                            this.stats.deliveredMessages++;
                            this.stats.totalHops += message.hopCount;
                            this.stats.totalDelay += (message.deliveryTime - message.createdAt);
                            this.logEvent(`✓ Message ${message.id} delivered to Vehicle ${nodeB.id}! Hops: ${message.hopCount}, Delay: ${(message.deliveryTime - message.createdAt).toFixed(1)}s`);
                        }
                    }
                });

                // NodeB to NodeA
                const messagesFromB = [...nodeB.messages];
                messagesFromB.forEach(message => {
                    if (!nodeA.messages.some(m => m.id === message.id)) {
                        const messageCopy = {...message};
                        messageCopy.hopCount++;
                        messageCopy.path.push(nodeA.id);
                        nodeA.messages.push(messageCopy);
                        nodeA.hasMessages = true;
                        nodeA.color = '#e74c3c';
                        exchanged = true;
                        
                        // Check if message reached its target
                        if (message.target === nodeA.id && !message.delivered) {
                            message.delivered = true;
                            message.deliveryTime = this.simulationTime;
                            this.stats.deliveredMessages++;
                            this.stats.totalHops += message.hopCount;
                            this.stats.totalDelay += (message.deliveryTime - message.createdAt);
                            this.logEvent(`✓ Message ${message.id} delivered to Vehicle ${nodeA.id}! Hops: ${message.hopCount}, Delay: ${(message.deliveryTime - message.createdAt).toFixed(1)}s`);
                        }
                    }
                });

                if (exchanged) {
                    this.logEvent(`Vehicles ${nodeA.id} & ${nodeB.id} exchanged messages`);
                }
            }

            draw() {
                // Clear canvas
                this.ctx.fillStyle = '#0c2461';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Draw roads
                this.drawRoads();
                
                // Draw communication ranges when vehicles are connected
                this.connections.forEach(connection => {
                    this.ctx.strokeStyle = 'rgba(46, 204, 113, 0.3)';
                    this.ctx.lineWidth = 2;
                    this.ctx.beginPath();
                    this.ctx.moveTo(connection.nodeA.x, connection.nodeA.y);
                    this.ctx.lineTo(connection.nodeB.x, connection.nodeB.y);
                    this.ctx.stroke();
                });

                // Draw vehicles
                this.nodes.forEach(node => {
                    this.drawVehicle(node);
                });
            }
            
            drawRoads() {
                this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                this.ctx.lineWidth = 40;
                
                // Horizontal roads
                this.ctx.beginPath();
                this.ctx.moveTo(0, 100);
                this.ctx.lineTo(this.canvas.width, 100);
                this.ctx.stroke();
                
                this.ctx.beginPath();
                this.ctx.moveTo(0, 250);
                this.ctx.lineTo(this.canvas.width, 250);
                this.ctx.stroke();
                
                this.ctx.beginPath();
                this.ctx.moveTo(0, 400);
                this.ctx.lineTo(this.canvas.width, 400);
                this.ctx.stroke();
                
                // Vertical roads
                this.ctx.beginPath();
                this.ctx.moveTo(200, 0);
                this.ctx.lineTo(200, this.canvas.height);
                this.ctx.stroke();
                
                this.ctx.beginPath();
                this.ctx.moveTo(500, 0);
                this.ctx.lineTo(500, this.canvas.height);
                this.ctx.stroke();
                
                // Road markings
                this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                this.ctx.lineWidth = 2;
                this.ctx.setLineDash([10, 10]);
                
                // Horizontal road markings
                for (let y of [100, 250, 400]) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(0, y);
                    this.ctx.lineTo(this.canvas.width, y);
                    this.ctx.stroke();
                }
                
                // Vertical road markings
                for (let x of [200, 500]) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(x, 0);
                    this.ctx.lineTo(x, this.canvas.height);
                    this.ctx.stroke();
                }
                
                this.ctx.setLineDash([]);
            }
            
            drawVehicle(node) {
                // Draw vehicle body
                this.ctx.fillStyle = node.color;
                this.ctx.fillRect(node.x - node.width/2, node.y - node.height/2, node.width, node.height);
                
                // Draw vehicle details based on direction
                this.ctx.fillStyle = '#2c3e50';
                if (node.direction === 'horizontal') {
                    // Draw windows
                    this.ctx.fillRect(node.x - node.width/2 + 5, node.y - node.height/2 + 3, 8, 5);
                    this.ctx.fillRect(node.x + node.width/2 - 13, node.y - node.height/2 + 3, 8, 5);
                    
                    // Draw wheels
                    this.ctx.fillRect(node.x - node.width/2 + 3, node.y - node.height/2 - 2, 5, 2);
                    this.ctx.fillRect(node.x + node.width/2 - 8, node.y - node.height/2 - 2, 5, 2);
                    this.ctx.fillRect(node.x - node.width/2 + 3, node.y + node.height/2, 5, 2);
                    this.ctx.fillRect(node.x + node.width/2 - 8, node.y + node.height/2, 5, 2);
                } else {
                    // Draw windows
                    this.ctx.fillRect(node.x - node.width/2 + 3, node.y - node.height/2 + 5, 5, 8);
                    this.ctx.fillRect(node.x - node.width/2 + 3, node.y + node.height/2 - 13, 5, 8);
                    
                    // Draw wheels
                    this.ctx.fillRect(node.x - node.width/2 - 2, node.y - node.height/2 + 3, 2, 5);
                    this.ctx.fillRect(node.x + node.width/2, node.y - node.height/2 + 3, 2, 5);
                    this.ctx.fillRect(node.x - node.width/2 - 2, node.y + node.height/2 - 8, 2, 5);
                    this.ctx.fillRect(node.x + node.width/2, node.y + node.height/2 - 8, 2, 5);
                }
                
                // Draw vehicle ID
                this.ctx.fillStyle = 'white';
                this.ctx.font = '10px Arial';
                this.ctx.textAlign = 'center';
                this.ctx.textBaseline = 'middle';
                this.ctx.fillText(node.id.toString(), node.x, node.y);
                
                // Draw message count if vehicle has messages
                if (node.messages.length > 0) {
                    this.ctx.fillStyle = '#c0392b';
                    this.ctx.beginPath();
                    this.ctx.arc(node.x + node.width/2 - 5, node.y - node.height/2 + 5, 6, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    this.ctx.fillStyle = 'white';
                    this.ctx.font = '8px Arial';
                    this.ctx.fillText(node.messages.length.toString(), node.x + node.width/2 - 5, node.y - node.height/2 + 5);
                }
            }

            updateStats() {
                document.getElementById('nodeCount').textContent = this.nodes.length;
                document.getElementById('totalMessages').textContent = this.stats.totalMessages;
                document.getElementById('deliveredMessages').textContent = this.stats.deliveredMessages;
                
                const deliveryRate = this.stats.totalMessages > 0 ? 
                    ((this.stats.deliveredMessages / this.stats.totalMessages) * 100).toFixed(1) : 0;
                document.getElementById('deliveryRate').textContent = `${deliveryRate}%`;
                
                const avgHops = this.stats.deliveredMessages > 0 ? 
                    (this.stats.totalHops / this.stats.deliveredMessages).toFixed(1) : 0;
                document.getElementById('avgHops').textContent = avgHops;
                
                const avgDelay = this.stats.deliveredMessages > 0 ? 
                    (this.stats.totalDelay / this.stats.deliveredMessages).toFixed(1) : 0;
                document.getElementById('avgDelay').textContent = `${avgDelay}s`;
                
                document.getElementById('activeConnections').textContent = this.stats.activeConnections;
            }

            logEvent(message) {
                const eventLog = document.getElementById('eventLog');
                const event = document.createElement('div');
                event.textContent = `[${this.formatTime(this.simulationTime)}] ${message}`;
                eventLog.appendChild(event);
                eventLog.scrollTop = eventLog.scrollHeight;
            }

            formatTime(seconds) {
                const mins = Math.floor(seconds / 60);
                const secs = Math.floor(seconds % 60);
                return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
            }

            clearEventLog() {
                document.getElementById('eventLog').innerHTML = '';
            }
        }

        // Initialize simulation when page loads
        document.addEventListener('DOMContentLoaded', () => {
            new VehicularDTNSimulation();
        });
    </script>
</body>
</html>  